import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import software.amazon.awssdk.services.sqs.SqsClient;
import software.amazon.awssdk.services.sqs.model.*;

import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class SqsConsumerServiceTest {

    @Mock
    private SqsClient sqsClient;

    @InjectMocks
    private SqsConsumerService sqsConsumerService;

    private final String queueUrl = "https://sqs.us-east-1.amazonaws.com/123456789012/test-queue";
    
    @BeforeEach
    void setUp() {
        // Simuler l'URL de la file
        Mockito.when(sqsClient.receiveMessage(any(ReceiveMessageRequest.class)))
                .thenReturn(ReceiveMessageResponse.builder().messages(Collections.emptyList()).build());
    }

    @Test
    void shouldProcessMessageSuccessfully() {
        // üìå Simuler un message dans la file
        Message mockMessage = Message.builder()
                .body("Hello SQS!")
                .receiptHandle("receipt-handle-123")
                .build();

        // Simuler la r√©ponse de SQS
        Mockito.when(sqsClient.receiveMessage(any(ReceiveMessageRequest.class)))
                .thenReturn(ReceiveMessageResponse.builder().messages(List.of(mockMessage)).build());

        // Ex√©cuter la m√©thode qui lit la file (une seule fois pour le test)
        sqsConsumerService.pollQueue();

        // V√©rifier que le message a √©t√© trait√©
        verify(sqsClient, times(1)).deleteMessage(any(DeleteMessageRequest.class));
    }

    @Test
    void shouldRetryOnFailureAndNotDeleteMessage() throws InterruptedException {
        // üìå Simuler un message qui va √©chouer
        Message mockMessage = Message.builder()
                .body("fail") // Ce message va provoquer une exception dans processMessage()
                .receiptHandle("receipt-handle-456")
                .build();

        // Simuler la r√©ponse de SQS
        Mockito.when(sqsClient.receiveMessage(any(ReceiveMessageRequest.class)))
                .thenReturn(ReceiveMessageResponse.builder().messages(List.of(mockMessage)).build());

        // Lancer la m√©thode de polling dans un thread pour ne pas bloquer les tests
        Thread pollingThread = new Thread(() -> sqsConsumerService.pollQueue());
        pollingThread.start();

        // Attendre 6 secondes pour laisser le retry se produire
        TimeUnit.SECONDS.sleep(6);

        // V√©rifier que deleteMessage() **n'a pas** √©t√© appel√© (car le traitement a √©chou√©)
        verify(sqsClient, never()).deleteMessage(any(DeleteMessageRequest.class));

        // Stopper la boucle infinie en interrompant le thread
        pollingThread.interrupt();
    }
}
